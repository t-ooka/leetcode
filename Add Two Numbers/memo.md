# step1

Acceptさせることができなかった。
問題を理解することに対して、不注意さがでた。
ListNodeはReverseOrderであることの意味がまずちゃんと理解できておらず、何回かテストケースを見て理解できた。（この辺はもう少し落ちついて読むことにする）

本題。繰り上げをどのように取得して、次のループに引き継ぐか迷った。
現在のノードのvalはmodを取ればいいだろう、繰り上げは10で割った商を持っていけばいいだろうと考える。（←ここまでは良さそうだった）

実際にコーディングするところで躓いてしまった。
まず、渡される `l1` と `l2` が同じ長さでないことを理解できてなかったので、もちろん通らない。
あれこれしている間に10分は過ぎたので答えを見た

# step2

繰り上げと余りを扱って計算していく方針は良さそうだった。
carryという変数をあらかじめ定義しておいて、ループを始めていた。アメリカ人の動画を見ていたので、なるほどcarryという変数は良いニュアンスそうだ。

ループの条件が `l1 or l2 or carry != 0` だった。見事に論理がコードがされていた。これを見ればすんなり理解できる。
以上を参考にコーディングしてみる。

時間計算量: O(N)
  渡される `l1` or `l2` のうち、長い方のノード数がN(carryが加わる場合もある）
空間計算量: O(N)
  新しくListNodeを定義して返すので、その長さ分のメモリが消費される


# step3

divmod()という関数があることをしり、これは便利なのでつかって実装をしてみた。
